#!/bin/bash
#
# hhmmss2sec -- translate syslog lines to time corresponding and human-
#                     comparable to times in PCAPS
#
# part of uncenz program, of the second part, the analysis
#
# Copyright (C) 2015 Miroslav Rovis, <http://www.CroatiaFidelis.hr/>
#
# released under BSD license, pls. see LICENSE
#
# I had started correlating events as recorded in both syslog messages and
# PCAPs at:
#
# Re: php-cgi and nonexisting connections to udp/80 (and udp/0
# https://forums.grsecurity.net/viewtopic.php?f=3&t=2951&p=16341#p16324
#
# and haven't made much progress in this meantime...
#
# This script converts hh:mm:ss (3 times 2 decimal digits, hh in range 0-24, mm
# in range 0-60, and ss in range 0-60) in file
#
# messages_161029_2021_g0n_TIMEShhmmss
#      what to call it?
# dump_161029_2021_g0n_messages_TIMEShhmmss
#
# one entry per line, to sec in normal range of integers, and most importantly
# for my case of comparison of logs and network traces, getting the relative
# period of time offset from the starting time for each line.
#
if [ $# -eq 0 ]; then
    echo "hhmmss2sec  times in syslog to time as in PCAPS"
    echo -e ""
    echo "Usage: $0 \$1 \$2 \$3"
    echo -e "    \$1 is the section of the logs corresponding to the trace"
    echo -e "        such as dump_161029_2021_g0n.pcap, named such as:"
    echo -e "        messages_161029_2021_g0n. If hhmmss2sec is run from"
    echo -e "        uncenz-2nd, that syslog excerpt is already cut by the time"
    echo -e "        it calls hhmmss2sec (this script)."
    echo -e "    \$2 is the time of 'exec of /usr/local/bin/uncenz-1st'"
    echo -e "        It ought to be converted to hh:mm:ss. It will become"
    echo -e "        the \$zero_value_raw in the script"
    echo -e "    \$3 is the number of seconds btwn that time and the time"
    echo -e "        that is recorded in the dumpcap (use capinfos) as"
    echo -e "        'First packet time'"
    echo -e "        It will become \$offset in the script"
    echo "    When hhmmss2sec is called by uncenz-2nd it finds and converts all"
    echo "        the argument automatically. Unless..."
    echo "        ...unless it's still broken."
    exit 0
fi

function ask()	# this function borrowed from "Advanced BASH Scripting Guide"
				# (a free book) by Mendel Cooper
{
    echo -n "$@" '[y/[n]] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

logs_section=$1
echo \$logs_section: $logs_section
zero_value_raw=$2
echo \$zero_value_raw: $zero_value_raw 
offset=$3
echo \$offset: $offset
#read FAKE;
# 2 PROBLEMS HERE
zero_value=""    # necessary?
# Nulling previous runs:
> zero_value    # necessary?
echo \$zero_value: $zero_value
#read FAKE;
> sec_rel
echo \$sec_rel: $sec_rel

zero_value_sec=""
echo "Must calculate \$zero_value_sec, $zero_value_sec (empty if nothing printed), before the loop."
#read FAKE;

    hh=$(echo $zero_value_raw|cut -d: -f1);
    mm=$(echo $zero_value_raw|cut -d: -f2);
    ss=$(echo $zero_value_raw|cut -d: -f3);
    echo the values are $hh $mm $ss;
#read FAKE;
    zero_value_sec=$(echo $hh*3600 + $mm*60 + $ss|bc)
    echo \$zero_value_sec: $zero_value_sec
#read FAKE;

cat $logs_section | awk '{ print $3 }' > ${logs_section}_TIMEShhmmss
ls -l $logs_section
echo "less $logs_section ?"
ask;
if [ "$?" == 0 ]; then
    less $logs_section
fi
echo "less ${logs_section}_TIMEShhmmss ?"
ask;
if [ "$?" == 0 ]; then
    less ${logs_section}_TIMEShhmmss
fi
for i in $(cat ${logs_section}_TIMEShhmmss); do
    hh=$(echo $i|cut -d: -f1);
    mm=$(echo $i|cut -d: -f2);
    ss=$(echo $i|cut -d: -f3);
    echo $i is $hh $mm $ss;
#read FAKE;
    sec=$(echo $hh*3600 + $mm*60 + $ss|bc)
    echo $sec
#read FAKE;
    # However we only need seconds relative to $zero_value_sec
    # So we need the sec of the first entry to subtract it from any later time
    echo "\$zero_value at start of loop: " $zero_value
    echo "\$zero_value_sec at start of loop: " $zero_value_sec
#read FAKE
    if [ "$zero_value" != "$zero_value_sec" ]; then
        if [ i=="zero_value_raw" ]; then
            echo $sec > zero_value ;
            zero_value=$(cat zero_value)
            echo "\$zero_value_sec in the if constuct: " $zero_value_sec
            echo "\$zero_value in the if constuct: " $zero_value
        fi ;
    fi
#read FAKE
    echo "\$zero_value at end of loop: " $zero_value
    echo "\$zero_value_sec at end of loop: " $zero_value_sec
    # relative to the start of uncenz-1st script
    sec_rel_uncenz=$(echo $sec-$zero_value|bc)
    echo \$sec_rel_uncenz: $sec_rel_uncenz
    # the difference btwn the starts of uncenz scripts in how Wireshark (with
    # capinfos I found) reckons the timing in the traces are btwn 5 and 6
    # seconds. I take $offset.
    sec_rel=$(echo $sec_rel_uncenz-$offset|bc)
    echo "\$sec_rel: " $sec_rel
    # End of this hasty conversion, just stow this $sec_rel value into a file
    echo $sec_rel >> sec_rel
    read FAKE
done
> sec_rel_fmt
for i in $(cat sec_rel); do printf "%05d\n" $i >> sec_rel_fmt ; done ;
#read FAKE;
ls -l ${logs_section} sec_rel_fmt
cat sec_rel_fmt | wc -l
sec_rel_fmt_wc_l=$(cat sec_rel_fmt | wc -l)
echo \$sec_rel_fmt_wc_l: $sec_rel_fmt_wc_l
cat ${logs_section}|cut -c8-9999 > PART2
PART2_wc_l=$(cat PART2 | wc -l)
echo \$PART2_wc_l: $PART2_wc_l
ts=$(echo ${logs_section}|sed 's/messages_//')
echo \$ts: $ts
read FAKE
read FAKE
read FAKE
read FAKE
if [ "$sec_rel_fmt_wc_l" == "$PART2_wc_l" ]; then
    paste -d' ' sec_rel_fmt PART2 > dump_${ts}_messages 
fi
read FAKE
