#!/bin/bash
#
# uncenz-1st -- first phase, screencasting and packet capturing
#
# Copyright (C) 2015 Miroslav Rovis, <http://www.CroatiaFidelis.hr/>
#
# released under BSD license, see LICENSE, or assume general BSD license,
# meaning you can do basically anything with these scripts except claim that
# you wrote them
#
# Uncenz is a set scripts for my method of engaging against censorship by
# documenting it to be able to call public or institutional attention, as well
# as discovering and documenting intrusion/other attacks to be able to seek
# help.

# The latter is related to the censorship issue since regimatic censorship is
# often accompanied with an array of possible attacks deliberate by same or
# related parties or purposefully allowed from non-related parties via sly
# means. All those possible attacks are intentional or allowed by the powerful
# subjects on the poor user, such as his/her own provider or possibly beyond.
#
# See topic:
#
# "Postfix smtp/TLS, Backup/Cloning Method, and Documenting
# Censorship/Intrusion"
# http://forums.gentoo.org/viewtopic-t-999436.html
#
# on Gentoo Forums.
#
# This is the first phase of my method. We try and start the screencast
# capturing with FFmpeg and tracing with dumpcap/tcpdump.
#
# If you don't want to reply to this question below every time, you can set
# either the string "dumpcap" or "tcpdump", no spaces, not extra char, just the
# usual newline at end, into:
# .uncenz-dumper_permanent
if [ -e ".uncenz-dumper_permanent" ]; then
	dumper=$(cat .uncenz-dumper_permanent)
	if [ "$dumper" == "dumpcap" ] || [ "$dumper" == "tcpdump" ]; then
		echo "\$dumper: $dumper, from your permanent setting";
		echo $dumper > .uncenz-dumper
	else
		echo "The string in the .uncenz-dumper_permanent is not one of"
		echo "the options this program is able to take, maybe a typo?"
	fi
	read FAKE
else
	echo "Can use Wireshark's dumpcap, or Tcpdump Team's tcpdump, you choose!"
	echo "\"d\" for dumpcap"
	echo "\"t\" for tcpdump"
	read choice
	case $choice in
		"d")
			dumper=dumpcap
		;;
	
		"t")
			dumper=tcpdump
		;;

		* )
			echo "only btwn dumpcap and tcpdump can you choose, at this time"
			echo "Pls. Ctrl-C, and make the correct/possible choice."
			exit
		;;
	esac
	echo \$dumper: $dumper
echo $dumper > .uncenz-dumper
read FAKE
fi
function show_help {
	echo
	echo "==============================================================="
	echo
	echo "$0 -- first phase of uncenz,"
	echo "screencasting and packet capturing"
	echo
	echo "version 0.22"
	echo
	echo "Usage: $0 [an-include-script-with-capture-filters]"
	echo ""
	echo "	Without arguments uncenz captures in promiscuous mode,"
	echo "	on all available interfaces."
	echo
	echo "	With first argument, an executable file \$include_filter_run,"
	echo "	it starts the $dumper with whatever its capture filter contains."
	echo "	\$include_filter_run is named with no spaces, and resides"
	echo "	where the $0 is regularly run from, usually in"
	echo "	/usr/local/bin ."
	echo
}

# First, the checks that apply to uncenz-1st run with and without the include
# alike.
#
# First of all, I don't go online if I don't capture traffic (and screencast),
# so: if I don't start this script first in other words), and I can't capture
# traffic if the $SSLKEYLOGFILE is not in place, so:
if [ ! -e "$SSLKEYLOGFILE" ]; then
	echo "There is no $SSLKEYLOGFILE. Fix that before you go online!"
	exit 0
fi

#echo
rm .gradm-S
sudo -s gradm -S > .gradm-S
gradm_S=$(cat .gradm-S)
if [ "$gradm_S" == "The RBAC system is currently disabled." ]; then
	echo "#####"
	echo "$gradm_S"
	echo
	echo " Do you really want to go online with Gradm disabled? "
	echo
	echo "[[play some sound here]]"
	echo
	echo "Disconnect, then Ctrl-C, and run uncenz-kill"
	echo "and then enable Gradm, or..."
	echo
	echo "... or hit Enter to continue."
	echo
	read FAKE
	echo
	echo "#####"
# Can't do the below w/o adding <user> to proc modify allowed group, I think.
#else if [ "$gradm_S" == "The RBAC system is currently enabled." ]; then
#		echo sysctl kernel.grsecurity.tpe
#		sudo -s sysctl kernel.grsecurity.tpe
#		echo sysctl kernel.grsecurity.tpe_restrict_all
#		sudo -s sysctl kernel.grsecurity.tpe_restrict_all
#		echo "should reenable these?"
#		read FAKE
#	fi
fi

# This line takes your hostname and retains only the first three letters to use
# in the infix
hostname_sh=$(hostname|sed 's/\(...\).*/\1/')
echo "\$hostname_sh: "; echo $hostname_sh
#read FAKE
#
# We must not start ffmpeg nor dumpcap/tcpdump if another session is running.
#
ffpidof=$(pidof ffmpeg)
echo "\$ffpidof: "; echo $ffpidof
ffpid=$(sudo -s ps aux | egrep 'ffmpeg' | grep x11grab | awk '{ print $2}')
echo "\$ffpid: "; echo $ffpid
dupidof=$(pidof $dumper)
echo "\$dupidof: "; echo $dupidof
#read FAKE
# In case you have a different display, surely you need to change this. Just,
# currently I want to try and get this script to work for me on the display I
# use on my box for online. No time here to make this work for other
# displays/display settings.
#
if [ -z "$ffpid" ] && [ -z "$dupidof" ] ; then
	# We'll be launching uncenz-ts . But for uncenz-ts to run properly it need to
	# be able to kill the process of the main script, this uncenz-1st one.
	ps aux | grep [u]ncenz-1st | awk '{ print $2 }' >  .uncenz-1st.pid
	echo "cat .uncenz-1st.pid"; cat .uncenz-1st.pid
	#read FAKE
	#
	# This uncenz-1st script needs to start ffmpeg screencasting and immediately
	# afterward network packet capturing. The two files that it will produce with
	# those processes that it will start, it needs to name with the same infix, and
	# so the first thing to run is actually the uncenz-ts:
	#
	uncenz-ts
	#
	# This stows the name to use in a file .uncenz-ts (ts is for "time stamp"), such
	# as "150207_0636" for 2015-02-06 06:36.
	#
	# Pretty dirty, but does it for me, this below is for the purpose that I
	# more easily find out if Palemoon (or Firefox), if active, is still
	# logging SSL-keys. It will just compare the previous SSLLAST to the new
	# just taken, by their hashes, and tell me to decide if they shouldn't
	# differ, if they do.
	tail -1 $SSLKEYLOGFILE > ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
	echo stored ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt ...
	chmod 600 ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
	ls -l ~/SSLLAST_$(cat .uncenz-ts.old)_${hostname_sh}.txt \
		~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
		ssllast_hash=$(sha256sum \
			~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt|cut -d' ' -f1)
		ssllast_hash_old=$(sha256sum \
			~/SSLLAST_$(cat .uncenz-ts.old)_${hostname_sh}.txt|cut -d' ' -f1)
		echo \$ssllast_hash, then \$ssllast_hash_old:
		echo $ssllast_hash
		echo $ssllast_hash_old
	if [ "$ssllast_hash" == "$ssllast_hash_old" ]; then
		echo
		echo "#####"
		echo
		echo " The last key is the same as at the start of last session "
		echo
		echo " If \$SSLKEYLOGFILE enable browser was active in the last session"
		echo " and opened https pages, it may have malfunctioned. "
		echo
		echo "							^^^	  ^^^^^^^^^^^^^ "
		echo "[[play some sound here]]"
		echo
		echo "Disconnect, then run uncenz-kill, and then Ctrl-C and investigate,"
		echo "or hit Enter to continue."
		echo "(If no SSL-key logging browser was active, all may still be fine.)"
		echo
		read FAKE
		echo
		echo "#####"
	fi

	# Still not in the clear about the below, but I think I both dumpcap and
	# tcpdump use pcapng even if you don't give them that extenstion. And...
	# And, I think for dumpcap, if it is not set to capture as <you, the normal
	# user> (still so here, was lazy about that... well, in grsecurity-hardened
	# system the root is not much more powerful than a normal user, so...), the
	# $the_dump needs to be touch'd.
	# Likewise for tcpdump, if it is not set to capture as <you, the normal
	# user>, which in my Gentoo machine means compiled with (the default)
	# "drop-root" use flag.
	the_dump=dump_$(cat .uncenz-ts)_${hostname_sh}.pcapng
	#the_dump_real=dump_$(cat .uncenz-ts)_${hostname_sh}.pcap
	export the_dump
	#export the_dump_real
	if [ "$dumper" == "dumpcap" ]; then
		sudo -s touch $the_dump
	fi
	#
	# When I have issues with configuring network (such as setting up bridges)
	# I like to take the state of the network when I'm online before I disconnect
	# (this is not to be taken every time by default, it's a lot, like debugging)
	#	echo
	#	echo "the iptables, and the link layer conf states"
	#	echo "		will be taken in 30 sec			 "
	#	echo "sleep 30 &&  sudo -s uncenz-ipt_conf_states.sh &"
	#	sleep 30 &&  sudo -s uncenz-ipt_conf_states.sh &
	#	sleep 1.5
	#	echo
	#

	#
	# Only one line starting with "sudo -s $dumper -i any ..." is allowed, of course.
	#
	
	if [ "$1" ]; then
		include_filter_run=$1
		echo \$include_filter_run: $include_filter_run
		# This is wrong! This checks for file in current dir.
		#if [ -e "$include_filter_run" ]; then ...
		#
		# Of course it would also need to check if it is executable, but, sorry, rush,
		# no time, and this suffices for my purposes.
		# So, will just check for...
		if [ -e "/usr/local/bin/$include_filter_run" ]; then 
				/usr/local/bin/$include_filter_run
			else
				echo "The include script you gave:"
				echo "$include_filter_run"
				echo "does not exist, or is not in the /usr/local/bin/ directory."
				sleep 3
				show_help
				exit 0
		fi
	else
		if [ "$dumper" == "dumpcap" ]; then
			sudo -s $dumper -i any -w $the_dump &
		fi
		if [ "$dumper" == "tcpdump" ]; then
			sudo -s $dumper -i any -Z tcpdump -U -v -w $the_dump &
		fi
		#sudo -s $dumper -i any -w $the_dump &
		echo "No hosts are filtered, all are traced, take notice!"; sleep 1.5
		#echo $the_dump_real
		#if [ -e "$the_dump" ]; then
		#	echo "Renaming $the_dump to $the_dump_real, is not pcapng an overkill extension?"
		#	mv -iv $the_dump $the_dump_real
		#fi		
	fi

	ffmpeg -f x11grab -nostdin -loglevel quiet -s 1024x768 -r 25 -i :1.0 \
		-c:v libx264 -preset ultrafast -threads 0 \
		Screen_$(cat .uncenz-ts)_${hostname_sh}.mkv &
	
	echo "Monitor screen 1024x768, take notice!"; sleep 1.5

else
	echo "An ffmpeg process is running, but is it uncenz's? Look up:" ; echo
	ls -ltr | tail -4 ; sleep 2 ; echo
	ls -ltr | tail -4 ; sleep 1
fi

#	ffmpeg -f x11grab -nostdin -loglevel quiet -s 800x600 -r 25 -i :1.0 \
#		-c:v libx264 -preset ultrafast -threads 0 \
#		Screen_$(cat .uncenz-ts)_${hostname_sh}.mkv &
#
#	echo "Monitor screen 800x600, take notice!"; sleep 1.5
#
# We need to find the pid of each of the above processes.
ffpid=$(sudo -s ps aux | egrep 'ffmpeg' | grep x11grab | awk '{ print $2}')
if [ "$dumper" == "dumpcap" ]; then
	dupid=`sudo -s ps aux | egrep '[d]umpcap' | awk '{ print $2}'`
fi
if [ "$dumper" == "tcpdump" ]; then
	dupid=`sudo -s ps aux | egrep '[t]cpdump' | awk '{ print $2}'`
fi

echo \$ffpid is: # ff for ffmpeg
echo $ffpid
echo \$dupid is: # du for $dumper
echo $dupid

echo "To end a session issue \"uncenz-kill <Enter>\" from its terminal."

exit 0
# vim: set tabstop=4 expandtab:
