#!/bin/bash
#
# uncenz-1st -- first phase, screencasting and packet capturing
#
# Copyright (C) 2015 Miroslav Rovis, <http://www.CroatiaFidelis.hr/>
#
# released under BSD license, see LICENSE, or assume general BSD license,
# meaning you can do basically anything with these scripts except claim that
# you wrote them
#
# Uncenz is a set scripts for my method of engaging against censorship by
# documenting it to be able to call public or institutional attention, as well
# as discovering and documenting intrusion/other attacks to be able to seek
# help.

# The latter is related to the censorship issue since regimatic censorship is
# often accompanied with an array of possible attacks deliberate by same or
# related parties or purposefully allowed from non-related parties via sly
# means. All those possible attacks are intentional or allowed by the powerful
# subjects on the poor user, such as his/her own provider or possibly beyond.
#
# See topic:
#
# "Postfix smtp/TLS, Backup/Cloning Method, and Documenting
# Censorship/Intrusion"
# http://forums.gentoo.org/viewtopic-t-999436.html
#
# on Gentoo Forums.
#
# This is the first phase of my method. We try and start the screencast
# capturing with FFmpeg and dumpcamp'ing with dumpcap.
#

function show_help {
    echo
    echo "==============================================================="
    echo
    echo "$0 -- first phase of uncenz,"
    echo "screencasting and packet capturing"
    echo
    echo "version 0.21"
    echo
    echo "Usage: $0 [an-include-script-with-capture-filters]"
    echo ""
    echo "    Without arguments uncenz captures in promiscuous mode,"
    echo "    on all available interfaces."
    echo
    echo "    With first argument, an executable file \$include_filter_run,"
    echo "    it starts the dumpcap with whatever its capture filter contains."
    echo "    \$include_filter_run is named with no spaces, and resides"
    echo "    where the $0 is regularly run from, usually in"
    echo "    /usr/local/bin ."
    echo
}

# First, the checks that apply to uncenz-1st run with and without the include
# alike.
#
# First of all, I don't go online if I don't capture traffic (and screencast),
# so: if I don't start this script first in other words), and I can't capture
# traffic if the $SSLKEYLOGFILE is not in place, so:
if [ ! -e "$SSLKEYLOGFILE" ]; then
    echo "There is no $SSLKEYLOGFILE. Fix that before you go online!"
    exit 0
fi

#echo
rm .gradm-S
sudo -s gradm -S > .gradm-S
gradm_S=$(cat .gradm-S)
if [ "$gradm_S" == "The RBAC system is currently disabled." ]; then
    echo "#####"
    echo "$gradm_S"
    echo
    echo " Do you really want to go online with Gradm disabled? "
    echo
    echo "[[play some sound here]]"
    echo
    echo "Disconnect, then Ctrl-C, and run uncenz-kill"
    echo "and then enable Gradm, or..."
    echo
    echo "... or hit Enter to continue."
    echo
    read FAKE
    echo
    echo "#####"
# Can't do the below w/o adding <user> to proc modify allowed group, I think.
#else if [ "$gradm_S" == "The RBAC system is currently enabled." ]; then
#        echo sysctl kernel.grsecurity.tpe
#        sudo -s sysctl kernel.grsecurity.tpe
#        echo sysctl kernel.grsecurity.tpe_restrict_all
#        sudo -s sysctl kernel.grsecurity.tpe_restrict_all
#        echo "should reenable these?"
#        read FAKE
#    fi
fi

# This line takes your hostname and retains only the first three letters to use
# in the infix
hostname_sh=$(hostname|sed 's/\(...\).*/\1/')
echo "\$hostname_sh: "; echo $hostname_sh
#read FAKE
#
# We must not start ffmpeg nor dumpcap if another session is running.
#
ffpidof=$(pidof ffmpeg)
echo "\$ffpidof: "; echo $ffpidof
ffpid=$(sudo -s ps aux | egrep 'ffmpeg' | grep x11grab | awk '{ print $2}')
echo "\$ffpid: "; echo $ffpid
dupidof=$(pidof dumpcap)
echo "\$dupidof: "; echo $dupidof
#read FAKE
# In case you have a different display, surely you need to change this. Just,
# currently I want to try and get this script to work for me on the display I
# use on my box for online. No time here to make this work for other
# displays/display settings.
#
if [ -z "$ffpid" ] && [ -z "$dupidof" ] ; then
    # We'll be launching uncenz-ts . But for uncenz-ts to run properly it need to
    # be able to kill the process of the main script, this uncenz-1st one.
    ps aux | grep [u]ncenz-1st | awk '{ print $2 }' >  .uncenz-1st.pid
    echo "cat .uncenz-1st.pid"; cat .uncenz-1st.pid
    #read FAKE
    #
    # This uncenz-1st script needs to start ffmpeg screencasting and immediately
    # afterward network packet capturing. The two files that it will produce with
    # those processes that it will start, it needs to name with the same infix, and
    # so the first thing to run is actually the uncenz-ts:
    #
    uncenz-ts
    #
    # This stows the name to use in a file .uncenz-ts (ts is for "time stamp"), such
    # as "150207_0636" for 2015-02-06 06:36.
    #
    # Pretty dirty, but does it for me, this below is for the purpose that I
    # more easily find out if Palemoon (or Firefox), if active, is still
    # logging SSL-keys. It will just compare the previous SSLLAST to the new
    # just taken, by their hashes, and tell me to decide if they shouldn't
    # differ, if they do.
    tail -1 $SSLKEYLOGFILE > ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
    echo stored ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt ...
    chmod 600 ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
    ls -l ~/SSLLAST_$(cat .uncenz-ts.old)_${hostname_sh}.txt \
        ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt
        ssllast_hash=$(sha256sum \
            ~/SSLLAST_$(cat .uncenz-ts)_${hostname_sh}.txt|cut -d' ' -f1)
        ssllast_hash_old=$(sha256sum \
            ~/SSLLAST_$(cat .uncenz-ts.old)_${hostname_sh}.txt|cut -d' ' -f1)
        echo \$ssllast_hash, then \$ssllast_hash_old:
        echo $ssllast_hash
        echo $ssllast_hash_old
    if [ "$ssllast_hash" == "$ssllast_hash_old" ]; then
        echo
        echo "#####"
        echo
        echo " The last key is the same as at the start of last session "
        echo
        echo " If \$SSLKEYLOGFILE enable browser was active in the last session"
        echo " and opened https pages, it may have malfunctioned. "
        echo
        echo "                            ^^^      ^^^^^^^^^^^^^ "
        echo "[[play some sound here]]"
        echo
        echo "Disconnect, then run uncenz-kill, and then Ctrl-C and investigate,"
        echo "or hit Enter to continue."
        echo "(If no SSL-key logging browser was active, all may still be fine.)"
        echo
        read FAKE
        echo
        echo "#####"
    fi

    the_dump=dump_$(cat .uncenz-ts)_${hostname_sh}.pcap
    export the_dump
    sudo -s touch $the_dump
    #
    # When I have issues with configuring network (such as setting up bridges)
    # I like to take the state of the network when I'm online before I disconnect
    # (this is not to be taken every time by default, it's a lot, like debugging)
    #    echo
    #    echo "the iptables, and the link layer conf states"
    #    echo "        will be taken in 30 sec             "
    #    echo "sleep 30 &&  sudo -s uncenz-ipt_conf_states.sh &"
    #    sleep 30 &&  sudo -s uncenz-ipt_conf_states.sh &
    #    sleep 1.5
    #    echo
    #

    #
    # Only one line starting with "sudo -s dumpcap -i any ..." is allowed, of course.
    #
    
    if [ "$1" ]; then
        include_filter_run=$1
        echo \$include_filter_run: $include_filter_run
        # This is wrong! This checks for file in current dir.
        #if [ -e "$include_filter_run" ]; then ...
        #
        # Of course it would also need to check if it is executable, but, sorry, rush,
        # no time, and this suffices for my purposes.
        # So, will just check for...
        if [ -e "/usr/local/bin/$include_filter_run" ]; then 
                /usr/local/bin/$include_filter_run
            else
                echo "The include script you gave:"
                echo "$include_filter_run"
                echo "does not exist, or is not in the /usr/local/bin/ directory."
                sleep 3
                show_help
                exit 0
        fi
    else
        sudo -s dumpcap -i any -w $the_dump &
        echo "No hosts are filtered, all are traced, take notice!"; sleep 1.5
        
    fi

    ffmpeg -f x11grab -nostdin -loglevel quiet -s 1024x768 -r 25 -i :1.0 \
        -c:v libx264 -preset ultrafast -threads 0 \
        Screen_$(cat .uncenz-ts)_${hostname_sh}.mkv &
    
    echo "Monitor screen 1024x768, take notice!"; sleep 1.5

else
    echo "An ffmpeg process is running, but is it uncenz's? Look up:" ; echo
    ls -ltr | tail -4 ; sleep 2 ; echo
    ls -ltr | tail -4 ; sleep 1
fi

#    ffmpeg -f x11grab -nostdin -loglevel quiet -s 800x600 -r 25 -i :1.0 \
#        -c:v libx264 -preset ultrafast -threads 0 \
#        Screen_$(cat .uncenz-ts)_${hostname_sh}.mkv &
#
#    echo "Monitor screen 800x600, take notice!"; sleep 1.5
#
# We need to find the pid of each of the above processes.
ffpid=$(sudo -s ps aux | egrep 'ffmpeg' | grep x11grab | awk '{ print $2}')
dupid=$(sudo -s ps aux | egrep '[d]umpcap' | awk '{ print $2}')

echo \$ffpid is: # ff for ffmpeg
echo $ffpid
echo \$dupid is: # du for dumpcap
echo $dupid

echo "To end a session issue \"uncenz-kill <Enter>\" from its terminal."

exit 0
# vim: set tabstop=4 expandtab:
