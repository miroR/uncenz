#!/bin/bash
#
# uncenz-2nd -- second phase, perusal of (a series of)
#			uncenz-1st -made screencast(s) and trace(s)
#			worked with (primitive) workPCAPs scripts
#
# (this is a rewrite after a number of failed attempts; it's primitive, but
# does allow quick analysis of main events by using now-improved uncenz-1st
# results)
#
# this script is part the uncenz set of scripts:
# https://github.com/miroR/uncenz
#
# recommended to run on results of:
# https://github.com/miroR/workPCAPs
#
# Copyright 2015, Miroslav Rovis, www.CroatiaFidelis.hr
#
# released under BSD license, pls. see LICENSE
#
function ask()
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
# When this rewrite was introduced, it could only work on all the PCAPs in a
# dir. Introducing (ah, getopts would be best, but the strategy to go for is
# far from clear to me yet) the list of PCAPs as first option (as in workPCAPs
# main script of some time by now).
if [ $# -eq 0 ]; then
	echo "give (a list of) file(s)"
	exit 0
fi

# You need to be in the directory where you ran uncenz-1st. First the
# PCAP-work.sh should be run (see workPCAPs link above). And the results of its
# run remaining in this same dir, also the dump_<the-time-stamp>_messages and
# the screencasts need to be in this same directory. Or elsewhere (but that's
# yet TO DO). Also dump_<the-time-stamp>_r represents another log extracted.
PCAPs=$1
echo \$PCAPs: $PCAPs
read FAKE
PCAPs_tr=$(ls -1 $1 | tr '\012' ' ')
echo \$PCAPs_tr: $PCAPs_tr
read FAKE
echo "ls -1 \$PCAPs|sed 's/\.pcap//'"
echo "ls -1 $PCAPs|sed 's/\.pcap//'"
ls -1 $PCAPs|sed 's/\.pcap//'
read FAKE
for i in $(ls -1 $PCAPs|sed 's/\.pcap//'); do
	ls -l $i.pcap
	read FAKE
	TMP="$(mktemp -d "/tmp/$i.$$.XXXXXXXX")"
	tmp_dir=$TMP
	export tmp_dir
	ls -ld $TMP
	ls -l $TMP
	read FAKE
	ls -l ${i}_tHostsConv/
	read FAKE
	scr=$(echo $i|sed 's/dump_\(.*\)/Screen_\1.mkv/')
	ls -l ./$scr
	ask
	if [ "$?" == 0 ]
		then mplayer -really-quiet ./$scr & scr_pid=$!
		echo $scr_pid > $TMP/${i}_scr.pid
		echo $(cat $TMP/${i}_scr.pid)
		read FAKE
	fi
	cd ${i}_tHostsConv/
	ls -1tr *.pcap
	read FAKE
	echo "View these PCAPs, one by one?"
	ask
	if [ "$?" == 0 ]; then
		num_pid=0
		for j in $(ls -1tr *.pcap); do
			wireshark $j &
			pid=$!
			echo $pid
			echo $pid > $TMP/${i}_${num_pid}.pid
			read FAKE
			ls -l $TMP/${i}_${num_pid}.pid
			read FAKE
			cat $TMP/${i}_${num_pid}.pid
			read FAKE
			let num_pid=$num_pid+1
			echo $num_pid: $num_pid
			read FAKE
		done
	fi
	read FAKE
	ls -1tr *.pcap
	cd -
	read FAKE
	ls -l ${i}_tHostsConv/
	read FAKE
	cd  ${i}_tHostsConv
	ls -1tr . ../${i}_messages ../${i}_tHostsConv.log ../${i}_r ../${i}_rn \
		| grep -v '\.pcap\|SSLKEYLOGFILE.txt'\
		| grep -v '\.:'|grep '[[:print:]]'
	read FAKE
	touch $TMP/${i}_list
	# ../${i}_tHostsConv/tsh*log is old-style, will be abandoned
	# for ../${i}_tHostsConv.log
	for file in $(ls -1tr . ../${i}_messages ../${i}_tHostsConv.log \
		../${i}_tHostsConv/tsh*log ../${i}_r ../${i}_rn \
		| grep -v '\.pcap\|SSLKEYLOGFILE.txt' | grep -v '\.:' \
		| grep '[[:print:]]'); do
		if [ -e "$file" ]; then
			echo "$file" >> $TMP/${i}_list
		fi
	done
	echo "The list of files to view in Vim is prepared."
	echo "And if you want to add other files for viewing now,"
	echo "edit the list."
	echo "Open the list in Vim for editing?"
	ask
	if [ "$?" == 0 ]; then
		vim $TMP/${i}_list
	fi
	echo "Now view these files in Vim?"
	ask
	if [ "$?" == 0 ]; then
		vim -p \
			$(cat $TMP/${i}_list)
	fi
	cd -
	read FAKE
	ls -l ${i}_tHostsConv/
	read FAKE
	echo "Terminate all windows opened with this run of $0?"
	ask
	if [ "$?" == 0 ]; then
		for curjobs in $(ls -1 $TMP/${i}*.pid); do
			pid=$(cat $curjobs)
			echo \$pid: $pid
			echo kill $pid
			kill $pid
		done
		sleep 0.1
		rm -rf $TMP/
	fi
	trap "rm -rf $TMP/" EXIT INT TERM
	export TMP
done
ls -l $TMP
read FAKE
trap "rm -rf $TMP/" EXIT INT TERM
# vim: set tabstop=4 expandtab:
