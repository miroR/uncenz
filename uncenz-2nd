#!/bin/bash
#
# uncenz-2nd -- second phase, perusal of (a series of)
#			uncenz-1st -made screencast(s) and trace(s)
#			worked with (primitive) workPCAPs scripts
#
# (this is a rewrite after a number of failed attempts; it's primitive, but
# does allow quick analysis of main events by using now-improved uncenz-1st
# results)
#
# this script is part the uncenz set of scripts:
# https://github.com/miroR/uncenz
#
# recommended to run on results of:
# https://github.com/miroR/workPCAPs 
#
# Copyright 2015, Miroslav Rovis, www.CroatiaFidelis.hr
#
# released under BSD license, pls. see LICENSE
#
function ask()
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
# When this rewrite was introduced, it could only work on all the PCAPs in a
# dir. Introducing (ah, getopts would be best, but the strategy to go for is
# far from clear to me yet) the list of PCAPs as first option (as in workPCAPs
# main script of some time by now).
if [ $# -eq 0 ]; then
	echo "give (a list of) file(s)"
	exit 0
fi

# You need to be in the directory where you ran uncenz-1st. First the
# PCAP-work.sh should be run (see workPCAPs link above). And the results of its
# run remaining in this same dir, also the dump_<the-time-stamp>_messages and
# the screencasts need to be in this same directory. Or elsewhere (but that's
# yet TO DO). Also dump_<the-time-stamp>_r represents another log extracted. 
PCAPs=$1
echo \$PCAPs: $PCAPs
read FAKE
PCAPs_tr=$(ls -1 $1 | tr '\012' ' ')
echo \$PCAPs_tr: $PCAPs_tr
read FAKE
echo "ls -1 \$PCAPs|sed 's/\.pcap//'"
echo "ls -1 $PCAPs|sed 's/\.pcap//'"
ls -1 $PCAPs|sed 's/\.pcap//'
read FAKE
for i in $(ls -1 $PCAPs|sed 's/\.pcap//'); do
	ls -l $i.pcap
	read FAKE
	TMP="$(mktemp -d "/tmp/$i.$$.XXXXXXXX")"
	tmp_dir=$TMP
	export tmp_dir
	ls -ld $TMP
	ls -l $TMP
	read FAKE
	ls -l ${i}_tHostsConv/
	read FAKE
	scr=$(echo $i|sed 's/dump_\(.*\)/Screen_\1.mkv/')
	ls -l ./$scr 
	ask 
	if [ "$?" == 0 ]
		then mplayer -really-quiet ./$scr & scr_pid=$! 
		echo $scr_pid > $TMP/${i}_scr.pid
		echo $(cat $TMP/${i}_scr.pid)
		read FAKE 
	fi 
	cd ${i}_tHostsConv/
	ls -1tr *.pcap
	read FAKE 
	echo "View these PCAPs, one by one?"
	ask 
	if [ "$?" == 0 ]; then
		num_pid=0
		for j in $(ls -1tr *.pcap); do
			wireshark $j &
			pid=$!
			echo $pid
			echo $pid > $TMP/${i}_${num_pid}
			read FAKE
			ls -l $TMP/${i}_${num_pid}
			read FAKE
			cat $TMP/${i}_${num_pid}
			read FAKE
			let num_pid=$num_pid+1
			echo $num_pid: $num_pid
			read FAKE
		done 
	fi 
	read FAKE 
	ls -1tr *.pcap
	cd - 
	read FAKE 
	ls -l ${i}_tHostsConv/
	read FAKE 
	cd  ${i}_tHostsConv 
	ls -1tr . ../${i}_messages  ../${i}_r | grep -v '\.pcap\|SSLKEYLOGFILE.txt'\
		| grep -v '\.:'|grep '[[:print:]]'
	read FAKE 
	ls -l $(ls -1tr . ../${i}_messages ../${i}_r \
		| grep -v '\.pcap\|SSLKEYLOGFILE.txt'|grep -v '\.:'|grep '[[:print:]]')
	echo "View these files in Vim?" 
	ask 
	if [ "$?" == 0 ]
		then vim -p \
			$(ls -1tr . ../${i}_messages ../${i}_r \
			| grep -v '\.pcap\|SSLKEYLOGFILE.txt' \
			| grep -v '\.:'|grep '[[:print:]]')
	fi
	cd - 
	read FAKE 
	ls -l ${i}_tHostsConv/
	read FAKE 
	echo "Terminate all windows opened with this run of $0?"
	ask
	if [ "$?" == 0 ]; then
		echo cat $TMP/${i}_scr.pid
		cat $TMP/${i}_scr.pid
		kill $(cat $TMP/${i}_scr.pid)
		sleep 0.1
		rm -v $TMP/${i}_scr.pid
		for wsh in $(ls -1 $TMP/${i}_*); do
			pid=$(cat $wsh)
			echo \$pid: $pid
			echo kill $pid
			kill $pid
		done
		sleep 0.1
		rm -rf $TMP/
	fi
	trap "rm -rf $TMP/" EXIT INT TERM
	export TMP
done 
ls -l $TMP
read FAKE
trap "rm -rf $TMP/" EXIT INT TERM
# vim: set tabstop=4 expandtab:
